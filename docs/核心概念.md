# 核心概念

本文档深入介绍 `reactive-response` 库的核心概念，包括响应对象设计、响应码体系和业务异常机制。理解这些核心概念将帮助您更好地使用该库构建健壮的响应式应用。

## 响应对象

### ReactiveResponse<T> 数据结构

`ReactiveResponse<T>` 是响应式编程场景下的通用响应包装类，采用泛型设计以支持不同类型的数据封装。该数据结构包含五个核心字段，形成统一的API响应格式。

#### 字段说明

- **`success`** (`boolean`)：表示操作是否成功，用于快速判断响应状态
  - `true`：操作成功
  - `false`：操作失败

- **`errorCode`** (`int`)：业务错误码，使用4位数字表示
  - 默认值：`0`（表示成功）
  - 用于标识具体的业务状态或错误类型
  - 便于客户端进行精确的错误处理

- **`message`** (`String`)：响应消息，向客户端传递可读的操作结果描述
  - 成功时：通常为"操作成功"或具体的成功描述
  - 失败时：包含具体的错误原因

- **`data`** (`T`)：响应数据，泛型类型，封装实际的业务数据
  - 成功响应：包含具体的数据对象
  - 失败响应：通常为 `null`

- **`timestamp`** (`long`)：时间戳，记录响应生成的时间
  - 自动初始化为 `System.currentTimeMillis()`
  - 确保每个响应都有准确的时间标记

#### JSON 序列化格式

```json
{
  "success": true,
  "errorCode": 0,
  "message": "操作成功",
  "data": {
    "id": "1",
    "name": "张三",
    "age": 30
  },
  "timestamp": 1631234567890
}
```

#### 静态工厂方法

`ReactiveResponse` 提供多种静态工厂方法用于创建响应对象：

```java
// 成功响应
ReactiveResponse<User> success = ReactiveResponse.success(user);
ReactiveResponse<User> successWithMessage = ReactiveResponse.success(user, "用户查询成功");

// 失败响应
ReactiveResponse<Object> failure = ReactiveResponse.failure("操作失败");
ReactiveResponse<Object> failureWithCode = ReactiveResponse.failure("用户不存在", 1001);

// 从异常创建失败响应
ReactiveResponse<Object> fromException = ReactiveResponse.failure(businessException);
```

## 响应码体系

### ResponseCode 枚举

`ResponseCode` 枚举定义了标准的响应状态码，实现了错误代码的统一管理和标准化处理。

#### 预定义响应码

##### SUCCESS - 操作成功
- **错误码**：`0`
- **消息**：`"操作成功"`
- **用途**：表示操作成功完成

##### UNAUTHORIZED - 认证失败
- **错误码**：`1001`
- **消息**：`"认证失败"`
- **用途**：表示用户认证失败，需要重新登录

##### FORBIDDEN - 权限不足
- **错误码**：`1002`
- **消息**：`"权限不足"`
- **用途**：表示用户已认证但权限不足

##### PARAMETER_ERROR - 参数错误
- **错误码**：`1003`
- **消息**：`"参数错误"`
- **用途**：表示请求参数不合法或缺失

##### NOT_FOUND - 资源不存在
- **错误码**：`1004`
- **消息**：`"资源不存在"`
- **用途**：表示请求的资源不存在（404类错误）

##### ERROR - 服务器错误
- **错误码**：`9999`
- **消息**：`"服务器错误"`
- **用途**：兜底错误码，用于处理未预期的系统异常

#### 枚举结构

```java
public enum ResponseCode {
    SUCCESS(0, "操作成功"),
    UNAUTHORIZED(1001, "认证失败"),
    FORBIDDEN(1002, "权限不足"),
    PARAMETER_ERROR(1003, "参数错误"),
    NOT_FOUND(1004, "资源不存在"),
    ERROR(9999, "服务器错误");
    
    private final int errorCode;
    private final String message;
    
    // 构造函数和getter方法
}
```

#### 自定义响应码

您可以根据业务需求扩展 `ResponseCode` 枚举：

```java
public enum CustomResponseCode {
    USER_NOT_FOUND(2001, "用户不存在"),
    EMAIL_ALREADY_EXISTS(2002, "邮箱已存在"),
    INVALID_PASSWORD(2003, "密码格式不正确"),
    ACCOUNT_LOCKED(2004, "账户已被锁定");
    
    private final int errorCode;
    private final String message;
    
    CustomResponseCode(int errorCode, String message) {
        this.errorCode = errorCode;
        this.message = message;
    }
    
    // getter方法...
}
```

## 业务异常

### BusinessException 设计

`BusinessException` 是专门用于封装业务逻辑异常的异常类，继承自 `RuntimeException`。它与响应码体系紧密集成，实现了异常信息与响应格式的无缝转换。

#### 核心特性

- **携带错误码**：每个异常实例都包含一个 `errorCode` 字段
- **多种构造方式**：支持不同的创建方式满足各种使用场景
- **响应集成**：可直接转换为 `ReactiveResponse` 失败响应
- **兼容性设计**：保持向后兼容的API设计

#### 构造函数重载

```java
// 仅消息，使用默认错误码1000
BusinessException exception1 = new BusinessException("操作失败");

// 自定义错误码和消息
BusinessException exception2 = new BusinessException(2001, "用户不存在");

// 从ResponseCode枚举创建
BusinessException exception3 = new BusinessException(ResponseCode.UNAUTHORIZED);

// 包含原始异常的异常链
BusinessException exception4 = new BusinessException("数据库连接失败", sqlException);

// ResponseCode枚举 + 原始异常
BusinessException exception5 = new BusinessException(ResponseCode.ERROR, dbException);
```

#### 使用示例

```java
@Service
public class UserService {
    
    public Mono<User> findById(Long id) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(new BusinessException(
                    ResponseCode.NOT_FOUND, "用户ID:" + id + "不存在")))
                .onErrorMap(DataAccessException.class, ex -> 
                    new BusinessException(ResponseCode.ERROR, "数据库访问错误", ex));
    }
    
    public Mono<User> createUser(CreateUserRequest request) {
        // 参数验证
        if (StringUtils.isEmpty(request.getEmail())) {
            return Mono.error(new BusinessException(
                ResponseCode.PARAMETER_ERROR, "邮箱不能为空"));
        }
        
        // 检查邮箱是否已存在
        return userRepository.existsByEmail(request.getEmail())
                .flatMap(exists -> {
                    if (exists) {
                        return Mono.error(new BusinessException(2002, "邮箱已存在"));
                    }
                    return userRepository.save(buildUser(request));
                });
    }
}
```

## 响应与错误处理范式

### 协同工作机制

`ReactiveResponse`、`ResponseCode` 和 `BusinessException` 三个核心组件协同工作，形成了完整的响应和错误处理范式。

```mermaid
flowchart TD
    A[业务方法执行] --> B{是否成功?}
    B -->|成功| C[返回 Mono/Flux 数据]
    B -->|业务异常| D[抛出 BusinessException]
    B -->|系统异常| E[抛出其他异常]
    
    C --> F[使用 ResponseBuilder.from()]
    D --> F
    E --> F
    
    F --> G[配置成功处理器]
    F --> H[配置业务异常处理器]
    F --> I[配置系统异常处理器]
    
    G --> J[生成成功响应]
    H --> K[生成业务错误响应]
    I --> L[生成系统错误响应]
    
    J --> M[Mono<ReactiveResponse<T>>]
    K --> M
    L --> M
```

### 处理流程示例

```java
@RestController
public class UserController {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final UserService userService;
    
    @GetMapping("/users/{id}")
    public Mono<ReactiveResponse<User>> getUser(@PathVariable Long id) {
        return responseBuilder.from(userService.findById(id))
                .successMessage("用户查询成功")
                .onBusinessException(this::handleBusinessException)
                .onError(this::handleSystemError)
                .build();
    }
    
    private ResponseCode handleBusinessException(BusinessException ex) {
        // 记录业务异常日志
        log.warn("业务异常: errorCode={}, message={}", 
                ex.getErrorCode(), ex.getMessage());
        
        // 返回异常中的响应码（如果是ResponseCode枚举）
        // 或者根据错误码映射到相应的ResponseCode
        return mapToResponseCode(ex.getErrorCode());
    }
    
    private ResponseCode handleSystemError(Throwable ex) {
        // 记录系统异常日志
        log.error("系统异常", ex);
        
        // 统一返回服务器错误码
        return ResponseCode.ERROR;
    }
    
    private ResponseCode mapToResponseCode(int errorCode) {
        return switch (errorCode) {
            case 1001 -> ResponseCode.UNAUTHORIZED;
            case 1002 -> ResponseCode.FORBIDDEN;
            case 1003 -> ResponseCode.PARAMETER_ERROR;
            case 1004 -> ResponseCode.NOT_FOUND;
            default -> ResponseCode.ERROR;
        };
    }
}
```

## 最佳实践

### 1. 异常设计原则

- **业务异常使用 BusinessException**：所有可预期的业务错误都应该抛出 `BusinessException`
- **携带合适的错误码**：使用预定义的 `ResponseCode` 或自定义错误码
- **提供清晰的错误消息**：错误消息应该对用户友好且具体

### 2. 响应构建原则

- **统一使用响应构建器**：避免直接创建 `ReactiveResponse` 对象
- **配置适当的异常处理器**：为不同类型的异常提供专门的处理逻辑
- **设置有意义的成功消息**：为成功响应提供清晰的描述

### 3. 错误码设计原则

- **分类管理**：按业务领域分配错误码段（如用户相关2xxx，订单相关3xxx）
- **避免重复**：确保每个错误码在系统中唯一
- **文档化**：维护完整的错误码文档供前端开发参考

---

*深入了解这些核心概念后，您可以继续阅读 [API参考](./API参考.md) 了解详细的API用法，或查看 [高级用法](./高级用法.md) 学习更多使用技巧。*