# 快速开始

## 简介

`reactive-response` 是一个专为响应式编程场景设计的 API 响应包装器，适用于 Spring WebFlux 或其他基于 Reactor 的项目。它提供统一的响应格式、链式构建语法，并支持自动配置和手动使用两种模式。本指南将帮助开发者快速在新项目中集成该库，涵盖从依赖引入到实际使用的完整流程。

## 添加依赖

要将 `reactive-response` 集成到您的项目中，首先需要通过构建工具添加依赖。

### Maven

在 `pom.xml` 文件中添加以下依赖项：

```xml
<dependency>
    <groupId>io.github.hzcssss</groupId>
    <artifactId>reactive-response-builder</artifactId>
    <version>1.0.2</version>
</dependency>
```

### Gradle

在 `build.gradle` 文件中添加：

```gradle
implementation 'io.github.hzcssss:reactive-response-builder:1.0.2'
```

### 版本兼容性

- **Java 11+**：项目最低要求 Java 11
- **Spring Boot 2.7+**：推荐使用 Spring Boot 2.7 或更高版本
- **Reactor Core 3.4+**：必需的响应式编程支持

## Spring Boot 用户使用指南

如果您使用的是 Spring Boot 项目，库会自动配置相关组件，您可以直接通过依赖注入使用。

### 1. 自动配置验证

库会在以下条件满足时自动配置：

- Classpath 中存在 `reactor-core`
- Classpath 中存在 `spring-webflux`
- 应用程序是 Web 应用

### 2. 依赖注入使用

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final UserService userService;
    
    // 构造函数注入
    public UserController(SpringReactiveResponseBuilder responseBuilder, 
                         UserService userService) {
        this.responseBuilder = responseBuilder;
        this.userService = userService;
    }
    
    @GetMapping("/{id}")
    public Mono<ReactiveResponse<User>> getUser(@PathVariable Long id) {
        return responseBuilder.from(userService.findById(id))
                .successMessage("用户查询成功")
                .onBusinessException(ex -> ResponseCode.USER_NOT_FOUND)
                .build();
    }
    
    @GetMapping
    public Mono<ReactiveResponse<List<User>>> getAllUsers() {
        return responseBuilder.from(userService.findAll().collectList())
                .successMessage("用户列表查询成功")
                .build();
    }
    
    @PostMapping
    public Mono<ReactiveResponse<User>> createUser(@RequestBody User user) {
        return responseBuilder.from(userService.save(user))
                .successCode(ResponseCode.CREATED)
                .successMessage("用户创建成功")
                .build();
    }
}
```

### 3. 服务层使用示例

```java
@Service
public class UserService {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final UserRepository userRepository;
    
    public UserService(SpringReactiveResponseBuilder responseBuilder,
                      UserRepository userRepository) {
        this.responseBuilder = responseBuilder;
        this.userRepository = userRepository;
    }
    
    public Mono<ReactiveResponse<User>> getUserWithValidation(Long id) {
        return responseBuilder.from(findUserById(id))
                .successMessage("用户验证成功")
                .onBusinessException(this::handleBusinessException)
                .onError(this::handleSystemError)
                .build();
    }
    
    private Mono<User> findUserById(Long id) {
        return userRepository.findById(id)
                .switchIfEmpty(Mono.error(new BusinessException("用户不存在", ResponseCode.USER_NOT_FOUND)));
    }
    
    private ResponseCode handleBusinessException(BusinessException ex) {
        return ex.getResponseCode();
    }
    
    private ResponseCode handleSystemError(Throwable ex) {
        return ResponseCode.INTERNAL_SERVER_ERROR;
    }
}
```

## 非 Spring 用户使用指南

如果您的项目不使用 Spring 框架，可以直接使用 `ReactiveResponseBuilder`。

### 1. 创建构建器实例

```java
public class UserService {
    
    private final ReactiveResponseBuilder responseBuilder = new ReactiveResponseBuilder();
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public Mono<ReactiveResponse<User>> getUser(Long id) {
        return responseBuilder.from(userRepository.findById(id))
                .successMessage("查询成功")
                .onBusinessException(ex -> ResponseCode.USER_NOT_FOUND)
                .build();
    }
}
```

### 2. 静态工具类使用

```java
import static io.github.hzcssss.reactive.response.util.ReactiveResponseUtil.*;

public class UserController {
    
    private final UserService userService;
    
    public Mono<ReactiveResponse<User>> getUser(Long id) {
        return success(userService.findById(id), "用户查询成功");
    }
    
    public Mono<ReactiveResponse<String>> deleteUser(Long id) {
        return userService.deleteById(id)
                .then(success("用户删除成功"));
    }
    
    public Mono<ReactiveResponse<Object>> handleError() {
        return error("操作失败", ResponseCode.INTERNAL_SERVER_ERROR);
    }
}
```

## 基本使用示例

### 成功响应

```java
// 简单成功响应
Mono<ReactiveResponse<String>> response = responseBuilder
        .success("操作成功")
        .build();

// 带数据的成功响应
Mono<ReactiveResponse<User>> userResponse = responseBuilder
        .from(userService.findById(1L))
        .successMessage("用户查询成功")
        .build();
```

### 错误响应

```java
// 简单错误响应
Mono<ReactiveResponse<Object>> errorResponse = responseBuilder
        .error("操作失败")
        .build();

// 带错误码的错误响应
Mono<ReactiveResponse<Object>> customErrorResponse = responseBuilder
        .error("用户不存在", ResponseCode.USER_NOT_FOUND)
        .build();
```

### 异常处理

```java
public Mono<ReactiveResponse<User>> getUserSafely(Long id) {
    return responseBuilder.from(userService.findById(id))
            .successMessage("查询成功")
            .onBusinessException(businessEx -> {
                // 处理业务异常
                log.warn("业务异常: {}", businessEx.getMessage());
                return businessEx.getResponseCode();
            })
            .onError(throwable -> {
                // 处理系统异常
                log.error("系统异常", throwable);
                return ResponseCode.INTERNAL_SERVER_ERROR;
            })
            .build();
}
```

## 关键配置与常见问题

### 自动配置故障排除

如果在 Spring Boot 项目中无法自动注入 `SpringReactiveResponseBuilder`，请检查：

1. **依赖版本**：确保使用 1.0.2 或更高版本
2. **Spring Boot版本**：推荐使用 2.7+ 版本
3. **包扫描**：确保自动配置类被正确扫描

### 日志配置

为了更好地调试自动配置过程，可以开启调试日志：

```properties
# application.properties
logging.level.io.github.hzcssss.reactive.response=DEBUG
```

### 性能优化建议

1. **单例使用**：`ReactiveResponseBuilder` 是线程安全的，建议作为单例使用
2. **避免重复创建**：在服务层缓存构建器实例
3. **异常处理**：合理配置异常处理器，避免异常在响应式流中传播

## 总结

通过以上步骤，您已经可以在项目中成功集成并使用 `reactive-response`。主要要点：

- **Spring Boot 用户**：通过依赖注入使用 `SpringReactiveResponseBuilder`
- **非 Spring 用户**：直接创建 `ReactiveResponseBuilder` 实例
- **统一响应格式**：所有 API 返回标准化的 JSON 结构
- **链式调用**：使用流畅的 API 语法构建响应

更多高级用法和最佳实践，请参阅：
- [核心概念](./核心概念.md) - 深入理解响应对象和异常处理
- [API参考](./API参考.md) - 完整的 API 文档
- [高级用法](./高级用法.md) - 性能优化和自定义配置

---

*遇到问题？查看 [GitHub Issues](https://github.com/hzcssss/reactive-response/issues) 或提交新的问题反馈。*