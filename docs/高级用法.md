# 高级用法

本文档深入介绍 `reactive-response` 库的高级使用技巧，包括自定义异常处理、响应转换与数据映射、性能优化等内容，帮助开发者充分发挥该库的潜力。

## 自定义异常处理

### 异常处理器设计模式

`reactive-response` 提供了灵活的异常处理机制，允许开发者根据不同的异常类型定制处理逻辑。

#### 基础异常处理器

```java
@Component
public class CustomExceptionHandler {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    
    public CustomExceptionHandler(SpringReactiveResponseBuilder responseBuilder) {
        this.responseBuilder = responseBuilder;
    }
    
    public <T> Mono<ReactiveResponse<T>> handleWithCustomLogic(Mono<T> mono) {
        return responseBuilder.from(mono)
                .successMessage("操作成功")
                .onBusinessException(this::handleBusinessException)
                .onError(this::handleSystemException)
                .build();
    }
    
    private ResponseCode handleBusinessException(BusinessException ex) {
        // 记录业务异常
        log.warn("业务异常 [{}]: {}", ex.getErrorCode(), ex.getMessage());
        
        // 根据错误码进行分类处理
        return switch (ex.getErrorCode()) {
            case 1001 -> {
                // 认证失败，可能需要重新登录
                publishAuthFailureEvent(ex);
                yield ResponseCode.UNAUTHORIZED;
            }
            case 1002 -> {
                // 权限不足，记录权限审计日志
                auditPermissionDenied(ex);
                yield ResponseCode.FORBIDDEN;
            }
            case 1003 -> {
                // 参数错误，记录请求参数
                logInvalidParameters(ex);
                yield ResponseCode.PARAMETER_ERROR;
            }
            default -> ResponseCode.ERROR;
        };
    }
    
    private ResponseCode handleSystemException(Throwable ex) {
        // 系统异常处理策略
        if (ex instanceof TimeoutException) {
            log.error("请求超时", ex);
            return createCustomResponseCode(5001, "请求超时，请稍后重试");
        } else if (ex instanceof DataAccessException) {
            log.error("数据库访问异常", ex);
            return createCustomResponseCode(5002, "数据访问异常");
        } else {
            log.error("未知系统异常", ex);
            return ResponseCode.ERROR;
        }
    }
    
    // 辅助方法
    private void publishAuthFailureEvent(BusinessException ex) {
        // 发布认证失败事件，可能触发账户锁定等安全策略
    }
    
    private void auditPermissionDenied(BusinessException ex) {
        // 记录权限拒绝的审计日志
    }
    
    private void logInvalidParameters(BusinessException ex) {
        // 记录无效参数的详细信息
    }
    
    private ResponseCode createCustomResponseCode(int code, String message) {
        // 创建自定义响应码（这里需要扩展ResponseCode enum或使用其他机制）
        return ResponseCode.ERROR; // 简化示例
    }
}
```

#### 链式异常处理器

```java
@Service
public class ChainedExceptionProcessor {
    
    private final List<ExceptionProcessor> processors;
    
    public ChainedExceptionProcessor(List<ExceptionProcessor> processors) {
        this.processors = processors;
    }
    
    public ResponseCode processException(Throwable ex) {
        return processors.stream()
                .filter(processor -> processor.canHandle(ex))
                .findFirst()
                .map(processor -> processor.process(ex))
                .orElse(ResponseCode.ERROR);
    }
    
    interface ExceptionProcessor {
        boolean canHandle(Throwable ex);
        ResponseCode process(Throwable ex);
    }
    
    @Component
    static class ValidationExceptionProcessor implements ExceptionProcessor {
        @Override
        public boolean canHandle(Throwable ex) {
            return ex instanceof MethodArgumentNotValidException ||
                   ex instanceof ConstraintViolationException;
        }
        
        @Override
        public ResponseCode process(Throwable ex) {
            log.warn("参数验证失败: {}", ex.getMessage());
            return ResponseCode.PARAMETER_ERROR;
        }
    }
    
    @Component
    static class SecurityExceptionProcessor implements ExceptionProcessor {
        @Override
        public boolean canHandle(Throwable ex) {
            return ex instanceof AccessDeniedException ||
                   ex instanceof AuthenticationException;
        }
        
        @Override
        public ResponseCode process(Throwable ex) {
            log.warn("安全异常: {}", ex.getMessage());
            return ex instanceof AuthenticationException ? 
                   ResponseCode.UNAUTHORIZED : ResponseCode.FORBIDDEN;
        }
    }
}
```

### 全局异常处理策略

#### WebFlux 全局异常处理器

```java
@Component
@Order(-2)  // 高优先级
public class GlobalWebExceptionHandler implements WebExceptionHandler {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final ObjectMapper objectMapper;
    
    public GlobalWebExceptionHandler(
            SpringReactiveResponseBuilder responseBuilder,
            ObjectMapper objectMapper) {
        this.responseBuilder = responseBuilder;
        this.objectMapper = objectMapper;
    }
    
    @Override
    public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
        ServerHttpResponse response = exchange.getResponse();
        
        // 设置响应头
        response.getHeaders().set(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
        
        // 构建错误响应
        ReactiveResponse<Object> errorResponse = buildErrorResponse(ex);
        
        // 写入响应体
        return writeResponse(response, errorResponse);
    }
    
    private ReactiveResponse<Object> buildErrorResponse(Throwable ex) {
        if (ex instanceof BusinessException businessEx) {
            return responseBuilder.failure(businessEx).build();
        } else if (ex instanceof WebExchangeBindException bindEx) {
            return responseBuilder.failure(ResponseCode.PARAMETER_ERROR.getErrorCode(),
                    "参数验证失败: " + extractFieldErrors(bindEx)).build();
        } else if (ex instanceof ResponseStatusException statusEx) {
            return responseBuilder.failure(statusEx.getStatus().value(),
                    statusEx.getReason()).build();
        } else {
            return responseBuilder.failure(ResponseCode.ERROR).build();
        }
    }
    
    private String extractFieldErrors(WebExchangeBindException ex) {
        return ex.getFieldErrors().stream()
                .map(error -> error.getField() + ": " + error.getDefaultMessage())
                .collect(Collectors.joining(", "));
    }
    
    private Mono<Void> writeResponse(ServerHttpResponse response, ReactiveResponse<Object> errorResponse) {
        try {
            byte[] bytes = objectMapper.writeValueAsBytes(errorResponse);
            DataBuffer buffer = response.bufferFactory().wrap(bytes);
            return response.writeWith(Mono.just(buffer));
        } catch (Exception e) {
            log.error("序列化错误响应失败", e);
            return response.setComplete();
        }
    }
}
```

## 响应转换与数据映射

### 数据转换管道

#### 响应数据映射器

```java
@Component
public class ResponseDataMapper {
    
    public <T, R> Mono<ReactiveResponse<R>> mapResponseData(
            Mono<ReactiveResponse<T>> responseMono,
            Function<T, R> mapper) {
        
        return responseMono.map(response -> {
            if (response.isSuccess() && response.getData() != null) {
                R mappedData = mapper.apply(response.getData());
                return ReactiveResponse.success(mappedData, response.getMessage());
            } else {
                // 失败响应直接返回，不进行数据映射
                return ReactiveResponse.failure(response.getMessage(), response.getErrorCode());
            }
        });
    }
    
    public <T> Mono<ReactiveResponse<List<T>>> flatMapResponseList(
            Mono<ReactiveResponse<List<T>>> responseMono,
            Function<T, Mono<T>> mapper) {
        
        return responseMono.flatMap(response -> {
            if (response.isSuccess() && response.getData() != null) {
                Flux<T> mappedFlux = Flux.fromIterable(response.getData())
                        .flatMap(mapper);
                
                return mappedFlux.collectList()
                        .map(mappedList -> ReactiveResponse.success(mappedList, response.getMessage()));
            } else {
                return Mono.just(ReactiveResponse.failure(response.getMessage(), response.getErrorCode()));
            }
        });
    }
}
```

#### 复杂数据转换示例

```java
@Service
public class UserDataTransformService {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final ResponseDataMapper dataMapper;
    
    public Mono<ReactiveResponse<UserDTO>> getUserWithProfile(Long userId) {
        return responseBuilder.from(userService.getUserWithDetails(userId))
                .successMessage("用户详情查询成功")
                .build()
                .flatMap(response -> dataMapper.mapResponseData(
                    Mono.just(response),
                    this::convertToUserDTO
                ));
    }
    
    public Mono<ReactiveResponse<PagedResponse<UserSummaryDTO>>> getPagedUsers(
            PageRequest pageRequest) {
        
        return responseBuilder.from(userService.findUsersWithPagination(pageRequest))
                .successMessage("分页查询成功")
                .build()
                .flatMap(response -> dataMapper.mapResponseData(
                    Mono.just(response),
                    this::convertToPagedUserSummary
                ));
    }
    
    private UserDTO convertToUserDTO(User user) {
        return UserDTO.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(maskEmail(user.getEmail()))  // 敏感信息脱敏
                .profile(convertProfile(user.getProfile()))
                .createdAt(user.getCreatedAt())
                .build();
    }
    
    private PagedResponse<UserSummaryDTO> convertToPagedUserSummary(PagedUsers pagedUsers) {
        List<UserSummaryDTO> summaries = pagedUsers.getUsers().stream()
                .map(this::convertToUserSummary)
                .collect(Collectors.toList());
        
        return PagedResponse.<UserSummaryDTO>builder()
                .content(summaries)
                .totalElements(pagedUsers.getTotalElements())
                .totalPages(pagedUsers.getTotalPages())
                .number(pagedUsers.getNumber())
                .size(pagedUsers.getSize())
                .build();
    }
    
    private UserSummaryDTO convertToUserSummary(User user) {
        return UserSummaryDTO.builder()
                .id(user.getId())
                .username(user.getUsername())
                .status(user.getStatus())
                .lastLoginAt(user.getLastLoginAt())
                .build();
    }
    
    private String maskEmail(String email) {
        if (email == null || !email.contains("@")) {
            return email;
        }
        String[] parts = email.split("@");
        String localPart = parts[0];
        if (localPart.length() <= 2) {
            return email;
        }
        return localPart.substring(0, 2) + "***@" + parts[1];
    }
}
```

### 响应缓存策略

#### 智能响应缓存

```java
@Component
public class ResponseCacheManager {
    
    private final CacheManager cacheManager;
    private final SpringReactiveResponseBuilder responseBuilder;
    
    public <T> Mono<ReactiveResponse<T>> cacheableResponse(
            String cacheKey,
            Supplier<Mono<T>> dataSupplier,
            Duration ttl) {
        
        Cache cache = cacheManager.getCache("responses");
        
        return Mono.fromCallable(() -> cache.get(cacheKey, ReactiveResponse.class))
                .cast(ReactiveResponse.class)
                .switchIfEmpty(
                    // 缓存未命中，执行原始逻辑
                    responseBuilder.from(dataSupplier.get())
                            .successMessage("数据获取成功")
                            .build()
                            .doOnNext(response -> {
                                if (response.isSuccess()) {
                                    // 只缓存成功响应
                                    cache.put(cacheKey, response);
                                }
                            })
                )
                .onErrorResume(ex -> {
                    // 缓存操作失败时的降级处理
                    log.warn("响应缓存操作失败", ex);
                    return responseBuilder.from(dataSupplier.get())
                            .successMessage("数据获取成功")
                            .build();
                });
    }
    
    public Mono<Void> invalidateCache(String pattern) {
        return Mono.fromRunnable(() -> {
            Cache cache = cacheManager.getCache("responses");
            // 根据模式清除缓存
            cache.evict(pattern);
        });
    }
}
```

## 性能优化与最佳实践

### 响应式流优化

#### 背压处理策略

```java
@Service
public class BackpressureOptimizedService {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    
    public Mono<ReactiveResponse<List<ProcessedData>>> processLargeDataset(
            Flux<RawData> dataFlux) {
        
        return responseBuilder.from(
                dataFlux
                        .onBackpressureBuffer(1000)  // 缓冲区大小
                        .concatMap(this::processData, 10)  // 并发度控制
                        .collectList()
        )
        .successMessage("大数据集处理完成")
        .onError(ex -> {
            if (ex instanceof OverflowException) {
                log.warn("背压溢出，数据处理过快");
                return ResponseCode.ERROR;  // 可以定义专门的背压错误码
            }
            return ResponseCode.ERROR;
        })
        .build();
    }
    
    public Flux<ReactiveResponse<ProcessedData>> streamProcessLargeDataset(
            Flux<RawData> dataFlux) {
        
        return dataFlux
                .onBackpressureLatest()  // 丢弃过期数据
                .map(this::processDataSync)
                .map(data -> responseBuilder.success(data)
                        .message("数据项处理完成")
                        .build())
                .onErrorContinue((ex, item) -> {
                    log.warn("处理数据项失败: {}", item, ex);
                });
    }
    
    private Mono<ProcessedData> processData(RawData rawData) {
        return Mono.fromCallable(() -> processDataSync(rawData))
                .subscribeOn(Schedulers.boundedElastic());
    }
    
    private ProcessedData processDataSync(RawData rawData) {
        // 同步处理逻辑
        return new ProcessedData(rawData);
    }
}
```

#### 内存使用优化

```java
@Service
public class MemoryOptimizedResponseService {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    
    public Mono<ReactiveResponse<Void>> processStreamWithoutCollection(Flux<DataItem> dataFlux) {
        // 避免将整个流收集到内存中
        return responseBuilder.from(
                dataFlux
                        .doOnNext(this::processItem)  // 流式处理
                        .then()  // 只关心完成信号，不收集数据
        )
        .successMessage("流式处理完成")
        .build();
    }
    
    public Mono<ReactiveResponse<StreamMetrics>> processWithMetrics(Flux<DataItem> dataFlux) {
        AtomicLong processedCount = new AtomicLong(0);
        AtomicLong errorCount = new AtomicLong(0);
        
        return responseBuilder.from(
                dataFlux
                        .doOnNext(item -> processedCount.incrementAndGet())
                        .doOnError(ex -> errorCount.incrementAndGet())
                        .onErrorContinue((ex, item) -> {
                            log.warn("处理数据项失败: {}", item, ex);
                        })
                        .then(Mono.fromSupplier(() -> new StreamMetrics(
                                processedCount.get(),
                                errorCount.get()
                        )))
        )
        .successMessage("流处理完成，包含统计信息")
        .build();
    }
    
    private void processItem(DataItem item) {
        // 处理单个数据项
    }
    
    record StreamMetrics(long processedCount, long errorCount) {}
}
```

### 响应构建优化

#### 构建器实例复用

```java
@Component
public class OptimizedResponseBuilder {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final ThreadLocal<Map<String, Object>> contextCache = 
            ThreadLocal.withInitial(HashMap::new);
    
    public <T> Mono<ReactiveResponse<T>> buildWithContext(
            Mono<T> dataMono,
            String contextKey,
            Object contextValue) {
        
        // 缓存上下文信息，避免重复计算
        contextCache.get().put(contextKey, contextValue);
        
        return responseBuilder.from(dataMono)
                .successMessage(computeSuccessMessage(contextKey))
                .onBusinessException(ex -> computeErrorCode(ex, contextKey))
                .build()
                .doFinally(signal -> contextCache.get().clear());  // 清理上下文
    }
    
    private String computeSuccessMessage(String contextKey) {
        Object context = contextCache.get().get(contextKey);
        // 根据上下文计算消息
        return context != null ? 
               "操作成功 - " + context.toString() : "操作成功";
    }
    
    private ResponseCode computeErrorCode(BusinessException ex, String contextKey) {
        Object context = contextCache.get().get(contextKey);
        // 根据上下文和异常信息计算错误码
        return ResponseCode.ERROR;
    }
}
```

#### 异步处理优化

```java
@Service
public class AsyncOptimizedService {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    private final Scheduler ioScheduler = Schedulers.newBoundedElastic(
            10, 1000, "response-io");  // 自定义调度器
    
    public Mono<ReactiveResponse<CombinedData>> getCombinedData(Long id) {
        Mono<UserData> userDataMono = getUserData(id)
                .subscribeOn(ioScheduler);
        
        Mono<ProfileData> profileDataMono = getProfileData(id)
                .subscribeOn(ioScheduler);
        
        Mono<SettingsData> settingsDataMono = getSettingsData(id)
                .subscribeOn(ioScheduler);
        
        return responseBuilder.from(
                Mono.zip(userDataMono, profileDataMono, settingsDataMono)
                        .map(tuple -> new CombinedData(
                                tuple.getT1(),
                                tuple.getT2(),
                                tuple.getT3()
                        ))
        )
        .successMessage("组合数据获取成功")
        .onError(ex -> {
            log.error("获取组合数据失败", ex);
            return ResponseCode.ERROR;
        })
        .build();
    }
    
    @PreDestroy
    public void cleanup() {
        ioScheduler.dispose();
    }
    
    private Mono<UserData> getUserData(Long id) {
        return Mono.fromCallable(() -> {
            // 模拟I/O操作
            return new UserData(id);
        });
    }
    
    private Mono<ProfileData> getProfileData(Long id) {
        return Mono.fromCallable(() -> {
            // 模拟I/O操作
            return new ProfileData(id);
        });
    }
    
    private Mono<SettingsData> getSettingsData(Long id) {
        return Mono.fromCallable(() -> {
            // 模拟I/O操作
            return new SettingsData(id);
        });
    }
    
    record CombinedData(UserData user, ProfileData profile, SettingsData settings) {}
    record UserData(Long id) {}
    record ProfileData(Long id) {}
    record SettingsData(Long id) {}
}
```

### 监控与诊断

#### 响应性能监控

```java
@Component
public class ResponseMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final Timer responseTimer;
    private final Counter successCounter;
    private final Counter errorCounter;
    
    public ResponseMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.responseTimer = Timer.builder("response.duration")
                .description("Response building duration")
                .register(meterRegistry);
        this.successCounter = Counter.builder("response.success")
                .description("Successful responses")
                .register(meterRegistry);
        this.errorCounter = Counter.builder("response.error")
                .description("Error responses")
                .register(meterRegistry);
    }
    
    public <T> Mono<ReactiveResponse<T>> measureResponse(
            Supplier<Mono<ReactiveResponse<T>>> responseSupplier) {
        
        return Mono.fromSupplier(responseSupplier)
                .flatMap(responseMono -> 
                    Timer.Sample.start(meterRegistry)
                            .flatMap(sample -> responseMono
                                    .doOnNext(response -> {
                                        sample.stop(responseTimer);
                                        if (response.isSuccess()) {
                                            successCounter.increment();
                                        } else {
                                            errorCounter.increment(
                                                Tags.of("error_code", 
                                                      String.valueOf(response.getErrorCode())));
                                        }
                                    })
                                    .doOnError(ex -> {
                                        sample.stop(responseTimer);
                                        errorCounter.increment(
                                            Tags.of("error_type", ex.getClass().getSimpleName()));
                                    })
                            )
                );
    }
}
```

### 最佳实践总结

#### 1. 异常处理最佳实践

- **分层处理**：业务异常在服务层处理，系统异常在控制器层统一处理
- **日志记录**：记录适当级别的日志，避免敏感信息泄露
- **异常映射**：建立明确的异常到响应码的映射关系
- **降级策略**：为异常情况提供合理的降级响应

#### 2. 性能优化最佳实践

- **流式处理**：优先使用流式处理，避免大量数据的内存收集
- **背压控制**：合理配置背压策略，防止内存溢出
- **调度器选择**：根据操作类型选择合适的调度器
- **资源管理**：及时释放资源，避免内存泄露

#### 3. 代码组织最佳实践

- **单一职责**：每个响应构建器专注于特定的业务场景
- **配置外部化**：将可变的配置参数外部化管理
- **测试覆盖**：为异常处理逻辑编写充分的测试用例
- **文档维护**：保持错误码和处理逻辑的文档同步

---

*更多高级主题和最新特性，请关注项目的 [GitHub 仓库](https://github.com/hzcssss/reactive-response) 和 [变更日志](../CHANGELOG.md)。*