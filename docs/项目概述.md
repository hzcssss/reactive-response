# 项目概述

## 项目定位与核心价值

`reactive-response` 是一个专为响应式编程场景设计的轻量级、无侵入性Java库，旨在为基于Spring WebFlux的响应式API开发提供统一的响应包装解决方案。该项目的核心价值在于通过标准化的响应结构和链式构建语法，显著提升API开发效率与代码可维护性。

项目设计遵循"按需使用"原则，既支持Spring Boot自动配置的便捷集成，也兼容非Spring环境下的直接调用，适用于各类响应式微服务架构。其无强制依赖的设计理念确保了对现有项目的低侵入性，开发者可自由选择集成方式而无需修改项目依赖结构。

## 核心功能特性

本项目提供以下关键功能特性，全面支持响应式API开发需求：

- **统一API响应格式**：通过`ReactiveResponse`类定义标准化的JSON响应结构，包含成功状态、错误码、消息、数据和时间戳字段。
- **响应式编程支持**：原生支持Reactor框架的`Mono`和`Flux`类型，提供无缝的响应包装能力。
- **Spring Boot自动配置**：通过`ReactiveResponseAutoConfiguration`实现开箱即用的Bean自动注册，简化Spring项目集成。
- **链式构建器模式**：提供流畅的API语法，支持方法链式调用构建响应对象。
- **业务错误码支持**：内置`ResponseCode`枚举和`BusinessException`异常类，便于统一管理业务错误。
- **多环境兼容**：Spring相关依赖设为`provided`和`optional`，确保在不同Spring版本间的灵活性。

## 模块化架构设计

项目采用清晰的模块化架构，各组件职责明确：

### 核心模块

- **`ReactiveResponse`** (`core`)：定义统一的响应数据结构
- **`ResponseCode`** (`core`)：标准响应码枚举定义
- **`BusinessException`** (`exception`)：业务异常类

### 构建器模块

- **`ReactiveResponseBuilder`** (`builder`)：基础构建器，支持非Spring环境
- **`SpringReactiveResponseBuilder`** (`service`)：Spring集成构建器，提供依赖注入支持
- **`ReactiveResponseService`** (`service`)：服务层封装

### 配置模块

- **`ReactiveResponseAutoConfiguration`** (`config`)：Spring Boot自动配置类

### 工具模块

- **`ReactiveResponseUtil`** (`util`)：工具类，提供便捷的静态方法

## 统一响应格式规范

项目定义的标准响应格式如下：

```json
{
  "success": true,
  "errorCode": 200,
  "message": "Success",
  "data": {},
  "timestamp": "2025-09-17T10:30:00Z"
}
```

### 字段说明

- **`success`** (`boolean`)：操作是否成功
- **`errorCode`** (`int`)：响应状态码，200表示成功
- **`message`** (`String`)：响应消息
- **`data`** (`T`)：业务数据，支持泛型
- **`timestamp`** (`String`)：响应时间戳，ISO 8601格式

## Spring Boot集成方案

### 自动配置机制

在Spring Boot环境中，`ReactiveResponseAutoConfiguration`会自动检测以下条件：

1. Classpath中存在`Reactor Core`依赖
2. Classpath中存在`Spring WebFlux`依赖
3. 当前环境为Web应用

满足条件时会自动注册`SpringReactiveResponseBuilder` Bean，开发者可直接通过依赖注入使用：

```java
@RestController
public class UserController {
    
    private final SpringReactiveResponseBuilder responseBuilder;
    
    public UserController(SpringReactiveResponseBuilder responseBuilder) {
        this.responseBuilder = responseBuilder;
    }
    
    @GetMapping("/users/{id}")
    public Mono<ReactiveResponse<User>> getUser(@PathVariable Long id) {
        return responseBuilder.from(userService.findById(id))
                .successMessage("用户查询成功")
                .build();
    }
}
```

### 版本兼容性

- **Spring Boot 2.x**：完全支持，已测试兼容2.7.18版本
- **Spring Boot 3.x**：理论兼容，需要Java 17+运行环境
- **依赖隔离**：Spring依赖标记为`provided`+`optional`，避免版本冲突

## 非Spring环境使用方式

对于非Spring项目，可直接使用`ReactiveResponseBuilder`：

```java
public class UserService {
    
    private final ReactiveResponseBuilder responseBuilder = new ReactiveResponseBuilder();
    
    public Mono<ReactiveResponse<User>> getUser(Long id) {
        return responseBuilder.from(findUserById(id))
                .successCode(ResponseCode.SUCCESS)
                .successMessage("查询成功")
                .onBusinessException(ex -> ResponseCode.USER_NOT_FOUND)
                .build();
    }
}
```

## 链式构建器模式详解

构建器模式提供了灵活且易读的API，支持以下链式调用：

### 基础构建方法

- **`.from(Mono<T>)`**：从Mono创建响应构建器
- **`.from(Flux<T>)`**：从Flux创建响应构建器
- **`.success(T data)`**：创建成功响应
- **`.error(String message)`**：创建错误响应

### 配置方法

- **`.successCode(ResponseCode)`**：设置成功状态码
- **`.successMessage(String)`**：设置成功消息
- **`.onBusinessException(Function)`**：设置业务异常处理器
- **`.onError(Function)`**：设置通用异常处理器

### 构建方法

- **`.build()`**：构建最终的`Mono<ReactiveResponse<T>>`
- **`.buildFlux()`**：构建最终的`Flux<ReactiveResponse<T>>`

## 项目优势

1. **零学习成本**：API设计直观，符合Java开发者习惯
2. **高度解耦**：不强制依赖Spring框架，适应多种项目结构
3. **性能优异**：原生支持响应式流，无额外性能开销
4. **可扩展性强**：支持自定义异常处理和响应转换
5. **社区友好**：开源MIT许可证，活跃的社区支持

## 使用场景

- **微服务架构**：统一服务间API响应格式
- **RESTful API**：标准化HTTP响应结构
- **响应式Web应用**：Spring WebFlux项目的最佳选择
- **API网关**：统一外部接口响应格式
- **前后端分离项目**：为前端提供一致的数据结构

---

*了解更多使用方法，请参阅 [快速开始](./快速开始.md) 和 [API参考](./API参考.md)。*