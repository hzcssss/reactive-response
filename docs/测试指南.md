# 测试指南

本指南旨在为开发者提供一套完整的测试策略，用于验证基于 `reactive-response` 库的响应式代码的正确性。通过分析项目自身的测试用例，我们将展示如何使用 Reactor 的 `StepVerifier` 来验证 `Mono` 和 `Flux` 响应流的行为，涵盖成功与失败场景。

## 核心测试组件概述

项目中的测试代码主要围绕以下几个核心组件展开：

- **`ReactiveResponseTest.java`**：测试基础响应对象和工具类
- **`SpringReactiveResponseTest.java`**：测试 Spring 集成的构建器服务
- **`ReactiveResponseAutoConfigurationTest.java`**：测试自动配置类的行为
- **`TestApplication.java`**：为集成测试提供 Spring Boot 上下文

这些测试类共同构成了一个全面的测试体系，覆盖了从基础对象到 Spring 集成的各个层面。

## 测试环境配置

### 测试依赖

确保在 `pom.xml` 中包含必要的测试依赖：

```xml
<dependencies>
    <!-- 主要测试框架 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Reactor 测试支持 -->
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- Spring Boot 测试支持 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    
    <!-- 响应式 Web 测试支持 -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webflux</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 测试应用配置

创建测试专用的 Spring Boot 应用：

```java
@SpringBootApplication
@ComponentScan(basePackages = "io.github.hzcssss.reactive.response")
public class TestApplication {
    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }
}
```

## 使用 StepVerifier 验证响应流

`StepVerifier` 是 Reactor 项目中用于测试响应式流的核心工具，允许我们以声明式的方式定义对 `Mono` 或 `Flux` 的期望。

### 验证成功响应

```java
@Test
public void testSuccessResponse() {
    // 准备测试数据
    String testData = "测试数据";
    Mono<String> dataMono = Mono.just(testData);
    
    // 使用构建器创建响应
    ReactiveResponseBuilder builder = new ReactiveResponseBuilder();
    Mono<ReactiveResponse<String>> responseMono = builder.from(dataMono)
            .successMessage("操作成功")
            .build();
    
    // 使用 StepVerifier 验证响应
    StepVerifier.create(responseMono)
            .assertNext(response -> {
                assertThat(response.isSuccess()).isTrue();
                assertThat(response.getData()).isEqualTo(testData);
                assertThat(response.getMessage()).isEqualTo("操作成功");
                assertThat(response.getErrorCode()).isEqualTo(0);
            })
            .verifyComplete();
}
```

### 验证失败响应

```java
@Test
public void testFailureResponse() {
    // 创建会抛出异常的 Mono
    BusinessException businessException = new BusinessException(
        ResponseCode.NOT_FOUND, "用户不存在");
    Mono<String> errorMono = Mono.error(businessException);
    
    // 构建响应
    ReactiveResponseBuilder builder = new ReactiveResponseBuilder();
    Mono<ReactiveResponse<String>> responseMono = builder.from(errorMono)
            .successMessage("查询成功")
            .onBusinessException(ex -> ex.getResponseCode())
            .build();
    
    // 验证失败响应
    StepVerifier.create(responseMono)
            .assertNext(response -> {
                assertThat(response.isSuccess()).isFalse();
                assertThat(response.getData()).isNull();
                assertThat(response.getErrorCode()).isEqualTo(1004);
                assertThat(response.getMessage()).contains("用户不存在");
            })
            .verifyComplete();
}
```

### 验证异常处理

```java
@Test
public void testExceptionHandling() {
    // 模拟系统异常
    RuntimeException systemException = new RuntimeException("数据库连接失败");
    Mono<String> errorMono = Mono.error(systemException);
    
    ReactiveResponseBuilder builder = new ReactiveResponseBuilder();
    Mono<ReactiveResponse<String>> responseMono = builder.from(errorMono)
            .successMessage("查询成功")
            .onError(ex -> ResponseCode.ERROR)
            .build();
    
    StepVerifier.create(responseMono)
            .assertNext(response -> {
                assertThat(response.isSuccess()).isFalse();
                assertThat(response.getErrorCode()).isEqualTo(9999);
                assertThat(response.getMessage()).contains("数据库连接失败");
            })
            .verifyComplete();
}
```

## 测试 SpringReactiveResponseBuilder

### 测试依赖注入

```java
@SpringBootTest
@ActiveProfiles("test")
class SpringReactiveResponseTest {
    
    @Autowired
    private SpringReactiveResponseBuilder responseBuilder;
    
    @Test
    public void testBuilderInjection() {
        assertThat(responseBuilder).isNotNull();
        assertThat(responseBuilder).isInstanceOf(SpringReactiveResponseBuilder.class);
    }
    
    @Test
    public void testFromMono() {
        User testUser = new User(1L, "test@example.com");
        Mono<User> userMono = Mono.just(testUser);
        
        Mono<ReactiveResponse<User>> responseMono = responseBuilder.from(userMono)
                .successMessage("用户查询成功")
                .build();
        
        StepVerifier.create(responseMono)
                .assertNext(response -> {
                    assertThat(response.isSuccess()).isTrue();
                    assertThat(response.getData()).isEqualTo(testUser);
                    assertThat(response.getMessage()).isEqualTo("用户查询成功");
                })
                .verifyComplete();
    }
    
    @Test
    public void testFromFlux() {
        List<User> users = Arrays.asList(
            new User(1L, "user1@example.com"),
            new User(2L, "user2@example.com")
        );
        Flux<User> userFlux = Flux.fromIterable(users);
        
        Mono<ReactiveResponse<List<User>>> responseMono = responseBuilder.from(userFlux)
                .successMessage("用户列表查询成功")
                .build();
        
        StepVerifier.create(responseMono)
                .assertNext(response -> {
                    assertThat(response.isSuccess()).isTrue();
                    assertThat(response.getData()).hasSize(2);
                    assertThat(response.getData()).containsAll(users);
                })
                .verifyComplete();
    }
}
```

### 测试成功与失败场景

```java
@Test
public void testSuccessBuilder() {
    User testUser = new User(1L, "test@example.com");
    
    ReactiveResponse<User> response = responseBuilder.success(testUser)
            .message("用户创建成功")
            .errorCode(201)
            .build();
    
    assertThat(response.isSuccess()).isTrue();
    assertThat(response.getData()).isEqualTo(testUser);
    assertThat(response.getMessage()).isEqualTo("用户创建成功");
    assertThat(response.getErrorCode()).isEqualTo(201);
}

@Test
public void testFailureBuilder() {
    ReactiveResponse<Object> response = responseBuilder.failure("用户不存在")
            .errorCode(1004)
            .build();
    
    assertThat(response.isSuccess()).isFalse();
    assertThat(response.getData()).isNull();
    assertThat(response.getMessage()).isEqualTo("用户不存在");
    assertThat(response.getErrorCode()).isEqualTo(1004);
}
```

### 测试异常处理器

```java
@Test
public void testBusinessExceptionHandler() {
    BusinessException businessException = new BusinessException(
        ResponseCode.UNAUTHORIZED, "认证失败");
    Mono<String> errorMono = Mono.error(businessException);
    
    Mono<ReactiveResponse<String>> responseMono = responseBuilder.from(errorMono)
            .successMessage("操作成功")
            .onBusinessException(ex -> {
                // 自定义业务异常处理逻辑
                if (ex.getErrorCode() == 1001) {
                    return ResponseCode.UNAUTHORIZED;
                }
                return ResponseCode.ERROR;
            })
            .build();
    
    StepVerifier.create(responseMono)
            .assertNext(response -> {
                assertThat(response.isSuccess()).isFalse();
                assertThat(response.getErrorCode()).isEqualTo(1001);
                assertThat(response.getMessage()).contains("认证失败");
            })
            .verifyComplete();
}
```

## 测试自动配置类

### 测试默认配置

```java
@TestConfiguration
class ReactiveResponseAutoConfigurationTest {
    
    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(ReactiveResponseAutoConfiguration.class));
    
    @Test
    public void testAutoConfiguration() {
        contextRunner.run(context -> {
            assertThat(context).hasSingleBean(SpringReactiveResponseBuilder.class);
            assertThat(context.getBean(SpringReactiveResponseBuilder.class))
                    .isNotNull();
        });
    }
    
    @Test
    public void testConditionalOnMissingBean() {
        contextRunner
                .withUserConfiguration(CustomConfiguration.class)
                .run(context -> {
                    assertThat(context).hasSingleBean(SpringReactiveResponseBuilder.class);
                    assertThat(context.getBean(SpringReactiveResponseBuilder.class))
                            .isInstanceOf(CustomSpringReactiveResponseBuilder.class);
                });
    }
    
    @Configuration
    static class CustomConfiguration {
        @Bean
        public SpringReactiveResponseBuilder springReactiveResponseBuilder() {
            return new CustomSpringReactiveResponseBuilder();
        }
    }
    
    static class CustomSpringReactiveResponseBuilder extends SpringReactiveResponseBuilder {
        // 自定义实现
    }
}
```

### 测试组件扫描

```java
@Test
public void testComponentScan() {
    contextRunner.run(context -> {
        // 验证核心组件都被正确扫描
        assertThat(context).hasSingleBean(SpringReactiveResponseBuilder.class);
        
        // 验证其他相关组件
        String[] beanNames = context.getBeanNamesForType(Object.class);
        assertThat(beanNames).contains("springReactiveResponseBuilder");
    });
}
```

## 集成测试

### 控制器层测试

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
class ControllerIntegrationTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Test
    public void testGetUser() {
        webTestClient.get()
                .uri("/api/users/1")
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isOk()
                .expectBody()
                .jsonPath("$.success").isEqualTo(true)
                .jsonPath("$.errorCode").isEqualTo(0)
                .jsonPath("$.message").isEqualTo("用户查询成功")
                .jsonPath("$.data.id").isEqualTo(1)
                .jsonPath("$.timestamp").exists();
    }
    
    @Test
    public void testUserNotFound() {
        webTestClient.get()
                .uri("/api/users/999")
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isOk()  // 业务错误仍返回200状态码
                .expectBody()
                .jsonPath("$.success").isEqualTo(false)
                .jsonPath("$.errorCode").isEqualTo(1004)
                .jsonPath("$.message").value(containsString("用户不存在"))
                .jsonPath("$.data").doesNotExist();
    }
}
```

### 服务层集成测试

```java
@SpringBootTest
@Transactional
@ActiveProfiles("test")
class ServiceIntegrationTest {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private SpringReactiveResponseBuilder responseBuilder;
    
    @Test
    public void testUserServiceWithResponse() {
        // 创建测试用户
        CreateUserRequest request = new CreateUserRequest("test@example.com", "password");
        
        Mono<ReactiveResponse<User>> responseMono = responseBuilder.from(
                userService.createUser(request))
                .successMessage("用户创建成功")
                .onBusinessException(ex -> ResponseCode.PARAMETER_ERROR)
                .build();
        
        StepVerifier.create(responseMono)
                .assertNext(response -> {
                    assertThat(response.isSuccess()).isTrue();
                    assertThat(response.getData().getEmail()).isEqualTo("test@example.com");
                })
                .verifyComplete();
    }
    
    @Test
    public void testDuplicateEmailHandling() {
        // 首先创建一个用户
        CreateUserRequest request1 = new CreateUserRequest("duplicate@example.com", "password");
        userService.createUser(request1).block();
        
        // 尝试创建相同邮箱的用户
        CreateUserRequest request2 = new CreateUserRequest("duplicate@example.com", "password2");
        
        Mono<ReactiveResponse<User>> responseMono = responseBuilder.from(
                userService.createUser(request2))
                .successMessage("用户创建成功")
                .onBusinessException(ex -> {
                    if (ex.getMessage().contains("邮箱已存在")) {
                        return ResponseCode.PARAMETER_ERROR;
                    }
                    return ResponseCode.ERROR;
                })
                .build();
        
        StepVerifier.create(responseMono)
                .assertNext(response -> {
                    assertThat(response.isSuccess()).isFalse();
                    assertThat(response.getErrorCode()).isEqualTo(1003);
                })
                .verifyComplete();
    }
}
```

## 性能测试

### 响应构建性能测试

```java
@Test
public void testResponseBuildingPerformance() {
    int iterations = 10000;
    ReactiveResponseBuilder builder = new ReactiveResponseBuilder();
    
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    
    List<Mono<ReactiveResponse<String>>> responses = new ArrayList<>();
    for (int i = 0; i < iterations; i++) {
        Mono<String> dataMono = Mono.just("test-data-" + i);
        Mono<ReactiveResponse<String>> responseMono = builder.from(dataMono)
                .successMessage("操作成功")
                .build();
        responses.add(responseMono);
    }
    
    // 批量执行
    Flux.fromIterable(responses)
            .flatMap(mono -> mono)
            .collectList()
            .block();
    
    stopWatch.stop();
    
    long totalTime = stopWatch.getTotalTimeMillis();
    double avgTime = (double) totalTime / iterations;
    
    log.info("构建 {} 个响应耗时: {}ms, 平均: {}ms", iterations, totalTime, avgTime);
    
    // 断言性能要求（例如：平均响应时间应小于1ms）
    assertThat(avgTime).isLessThan(1.0);
}
```

### 内存使用测试

```java
@Test
public void testMemoryUsage() {
    Runtime runtime = Runtime.getRuntime();
    long initialMemory = runtime.totalMemory() - runtime.freeMemory();
    
    ReactiveResponseBuilder builder = new ReactiveResponseBuilder();
    List<ReactiveResponse<String>> responses = new ArrayList<>();
    
    // 创建大量响应对象
    for (int i = 0; i < 100000; i++) {
        ReactiveResponse<String> response = builder.success("data-" + i)
                .message("消息-" + i)
                .build();
        responses.add(response);
    }
    
    long peakMemory = runtime.totalMemory() - runtime.freeMemory();
    long memoryUsed = peakMemory - initialMemory;
    
    log.info("创建100000个响应对象使用内存: {} bytes ({}MB)", 
             memoryUsed, memoryUsed / 1024 / 1024);
    
    // 清理并强制GC
    responses.clear();
    System.gc();
    
    long finalMemory = runtime.totalMemory() - runtime.freeMemory();
    long memoryReleased = peakMemory - finalMemory;
    
    log.info("GC后释放内存: {} bytes ({}MB)", 
             memoryReleased, memoryReleased / 1024 / 1024);
    
    // 断言内存使用合理（具体数值根据实际情况调整）
    assertThat(memoryUsed).isLessThan(100 * 1024 * 1024); // 小于100MB
}
```

## 测试工具类和模板

### 可复用的测试工具

```java
public class ResponseTestUtils {
    
    public static <T> void assertSuccessResponse(ReactiveResponse<T> response, 
                                                T expectedData, 
                                                String expectedMessage) {
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getData()).isEqualTo(expectedData);
        assertThat(response.getMessage()).isEqualTo(expectedMessage);
        assertThat(response.getErrorCode()).isEqualTo(0);
        assertThat(response.getTimestamp()).isGreaterThan(0);
    }
    
    public static void assertFailureResponse(ReactiveResponse<?> response, 
                                           int expectedErrorCode, 
                                           String expectedMessagePart) {
        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getData()).isNull();
        assertThat(response.getErrorCode()).isEqualTo(expectedErrorCode);
        assertThat(response.getMessage()).contains(expectedMessagePart);
        assertThat(response.getTimestamp()).isGreaterThan(0);
    }
    
    public static <T> Consumer<ReactiveResponse<T>> expectSuccess(T expectedData) {
        return response -> assertSuccessResponse(response, expectedData, null);
    }
    
    public static Consumer<ReactiveResponse<?>> expectFailure(int errorCode) {
        return response -> {
            assertThat(response.isSuccess()).isFalse();
            assertThat(response.getErrorCode()).isEqualTo(errorCode);
        };
    }
}
```

### 测试数据构建器

```java
public class TestDataBuilder {
    
    public static User createTestUser() {
        return User.builder()
                .id(1L)
                .username("testuser")
                .email("test@example.com")
                .createdAt(LocalDateTime.now())
                .build();
    }
    
    public static BusinessException createBusinessException(ResponseCode responseCode) {
        return new BusinessException(responseCode, "测试业务异常");
    }
    
    public static <T> Mono<T> createDelayedMono(T data, Duration delay) {
        return Mono.just(data).delayElement(delay);
    }
    
    public static <T> Mono<T> createErrorMono(Throwable error) {
        return Mono.error(error);
    }
}
```

## 最佳实践

### 1. 测试命名规范

```java
// 好的命名示例
@Test
public void shouldReturnSuccessResponse_WhenUserExists()
@Test  
public void shouldReturnNotFoundError_WhenUserDoesNotExist()
@Test
public void shouldHandleBusinessException_WhenValidationFails()
```

### 2. 测试数据管理

```java
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ResponseBuilderTest {
    
    private ReactiveResponseBuilder builder;
    private User testUser;
    
    @BeforeAll
    void setup() {
        builder = new ReactiveResponseBuilder();
        testUser = TestDataBuilder.createTestUser();
    }
    
    @Test
    void testSuccess() {
        // 使用预设的测试数据
    }
}
```

### 3. 异步测试超时设置

```java
@Test
@Timeout(value = 5, unit = TimeUnit.SECONDS)
public void testWithTimeout() {
    StepVerifier.create(responseMono)
            .expectNext(expectedResponse)
            .verifyComplete();
}
```

### 4. 测试隔离

```java
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
class IsolatedTest {
    // 确保每个测试方法后重新创建应用上下文
}
```

---

*通过遵循这些测试指南和最佳实践，您可以确保基于 `reactive-response` 库的代码具有高质量和可靠性。更多测试示例请参考项目的 [测试代码](../src/test/java/io/github/hzcssss/reactive/response)。*